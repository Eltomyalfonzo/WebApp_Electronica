<!DOCTYPE html>
<html>
<head>
  <title>MQTT - Magnitud, Fase y Nyquist</title>
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Poppins', sans-serif; margin:0; padding:0; }
    .navbar {
      display:flex;
      align-items:center;
      justify-content:space-between;
      background-color:#003366;
      color:white;
      padding:10px 20px;
    }
    .navbar button {
      background-color:#007BFF;
      color:white;
      border:none;
      padding:8px 15px;
      border-radius:5px;
      cursor:pointer;
      font-size:14px;
    }
    .navbar button:hover { background-color:#0056b3; }

    .container { display:flex; gap:20px; padding:20px; }
    .charts-left { flex:1; }
    .charts-right { flex:1; display:flex; flex-direction:column; align-items:center; }
    canvas { width: 400px; height: 300px; display:block; margin-bottom:15px; }
    form { margin:20px; display:flex; justify-content:center; flex-wrap:wrap; gap:10px; }
    input { padding:5px; margin-right:10px; }
    img { max-width:200px; margin-bottom:20px; display:block; margin-left:auto; margin-right:auto; }
    pre { background:#f0f0f0; padding:10px; height:120px; overflow:auto; }
    .sweep-controls { text-align:center; margin-top:20px; }
    .sweep-controls input { width:80px; text-align:center; }
    .sweep-controls button { background-color:#28a745; color:white; border:none; padding:8px 15px; border-radius:5px; cursor:pointer; }
    .sweep-controls button:hover { background-color:#1e7e34; }
    .stop-btn { background-color:#dc3545 !important; }
  </style>
</head>
<body>

<div class="navbar">
  <span>MQTT - Respuesta en Frecuencia - UTN - Facultad Regional San Francisco</span>
  <button onclick="downloadAllCharts()">Descargar Todos</button>
</div>

<div class="container">
  <div class="charts-left">
    <canvas id="chartMag"></canvas>
    <canvas id="chartPhase"></canvas>
  </div>
  <div class="charts-right">
    <canvas id="chartNyquist"></canvas>
  </div>
</div>

<form onsubmit="sendData(event)">
  <input id="deviceId" placeholder="ID del dispositivo (ej: ESP32_A1)" required>
  <button type="button" onclick="connectDevice()">Conectar</button>
  <input id="inputData" placeholder="-10;1000A o 1.57;1000F o S1000">
  <button>Enviar</button>
</form>

<pre id="log"></pre>

<!-- === Barrido de Frecuencia === -->
<div class="sweep-controls">
  <h3>‚ö° Barrido de Frecuencia</h3>
  <label>Inicio [Hz]: <input id="startFreq" type="number" value="100" step="1"></label>
  <label>Fin [Hz]: <input id="endFreq" type="number" value="1000" step="1"></label>
  <label>Paso [Hz]: <input id="stepFreq" type="number" value="100" step="1"></label>
  <label>Espera [s]: <input id="waitTime" type="number" value="1" step="0.1"></label>
  <button onclick="startSweep()">Start Sweep</button>
  <button onclick="stopSweep()" class="stop-btn">Stop</button>
</div>

<script>
const socket = io();
let currentDevice = null;

// ==========================
// üîå Conectar con dispositivo
// ==========================
function connectDevice() {
  const id = document.getElementById("deviceId").value.trim();
  if (!id) return log("‚ö†Ô∏è Ingrese un ID de dispositivo.");
  currentDevice = id;
  socket.emit("join_device", id);
  socket.emit("connect_device", id);
  log(`üîó Intentando conectar con ${id}...`);
}

// üì© Recibir datos desde backend
socket.on("update_data", ({ deviceId, payload }) => {
  if (!currentDevice || deviceId !== currentDevice) return;
  if (typeof payload === "string") parsePlot(payload);
  else if (payload.msg) parsePlot(payload.msg);
});

// üì§ Enviar comando (MQTT ‚Üí ESP32)
function sendData(e){
  e.preventDefault();
  const v = document.getElementById("inputData").value.trim();
  const id = document.getElementById("deviceId").value.trim();
  if(!v || !id) return;
  socket.emit("send_command", { deviceId: id, command: v });
  log(`üì§ Enviado a ${id}: ${v}`);
  document.getElementById("inputData").value = "";
}

// üßæ Log auxiliar
function log(msg){
  const logEl = document.getElementById("log");
  logEl.textContent += msg + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}

// ==========================
//      GRAFICOS
// ==========================
Chart.defaults.font.family = 'Poppins';
Chart.defaults.font.size = 14;

const chartMag = new Chart(document.getElementById('chartMag'), {
  type:'line',
  data:{labels:[], datasets:[{label:'Magnitud [dB]', data:[], borderColor:'blue', backgroundColor:'rgba(0,0,255,0.1)', fill:true}]},
  options:{
    responsive:false,
    scales:{
      x:{type:'logarithmic', title:{display:true, text:'Frecuencia [rad/s]', font:{size:16}}},
      y:{title:{display:true, text:'Magnitud [dB]', font:{size:16}}}
    }
  }
});

const chartPhase = new Chart(document.getElementById('chartPhase'), {
  type:'line',
  data:{labels:[], datasets:[{label:'Fase [rad]', data:[], borderColor:'red', backgroundColor:'rgba(255,0,0,0.1)', fill:true}]},
  options:{
    responsive:false,
    scales:{
      x:{type:'logarithmic', title:{display:true, text:'Frecuencia [rad/s]', font:{size:16}}},
      y:{title:{display:true, text:'Fase [rad]', font:{size:16}}}
    }
  }
});

const chartNyquist = new Chart(document.getElementById('chartNyquist'), {
  type:'line',
  data:{labels:[], datasets:[{label:'Nyquist', data:[], borderColor:'blue', fill:false}]},
  options:{
    responsive:false,
    scales:{
      x:{title:{display:true,text:'Re', font:{size:16}}},
      y:{title:{display:true,text:'Im', font:{size:16}}}
    }
  }
});

let latestMagnitude = NaN;
let latestPhase = NaN;

function parsePlot(msg){
  const m = msg.match(/^([-+]?[0-9]*\.?[0-9]+);([0-9]*\.?[0-9]+)([AF])$/);
  if(!m){ log("‚ö†Ô∏è Formato inv√°lido: " + msg); return; }
  const val = parseFloat(m[1]), freq = parseFloat(m[2]), type = m[3];

  if(type==="A"){
    chartMag.data.labels.push(freq);
    chartMag.data.datasets[0].data.push(val);
    chartMag.update();
    latestMagnitude = Math.pow(10, val/20);
    if(!isNaN(latestPhase)) addNyquist(latestMagnitude, latestPhase);
  } else if(type==="F"){
    chartPhase.data.labels.push(freq);
    chartPhase.data.datasets[0].data.push(val);
    chartPhase.update();
    latestPhase = val;
    if(!isNaN(latestMagnitude)) addNyquist(latestMagnitude, latestPhase);
  }
}

function addNyquist(mag, phase){
  const re = mag * Math.cos(phase);
  const im = mag * Math.sin(phase);
  chartNyquist.data.labels.push('');
  chartNyquist.data.datasets[0].data.push({x:re, y:im});
  chartNyquist.update();
}

function downloadAllCharts(){
  const charts = [
    {chart: chartMag, defaultName: 'magnitud.png'},
    {chart: chartPhase, defaultName: 'fase.png'},
    {chart: chartNyquist, defaultName: 'nyquist.png'}
  ];
  charts.forEach(c => {
    const filename = prompt(`Nombre para guardar ${c.defaultName}`, c.defaultName);
    if(filename){
      const link = document.createElement('a');
      link.href = c.chart.toBase64Image();
      link.download = filename;
      link.click();
    }
  });
}

// ==========================
// üîÅ Barrido Autom√°tico
// ==========================
let sweepRunning = false;

async function startSweep() {
  if (sweepRunning) {
    log("‚ö†Ô∏è Barrido ya en ejecuci√≥n.");
    return;
  }

  const start = parseFloat(document.getElementById("startFreq").value);
  const end = parseFloat(document.getElementById("endFreq").value);
  const step = parseFloat(document.getElementById("stepFreq").value);
  const waitSec = parseFloat(document.getElementById("waitTime").value);
  const id = document.getElementById("deviceId").value.trim();

  if (!id || isNaN(start) || isNaN(end) || isNaN(step) || isNaN(waitSec)) {
    log("‚ö†Ô∏è Complete todos los campos correctamente.");
    return;
  }

  if (end <= start || step <= 0) {
    log("‚ö†Ô∏è Valores inv√°lidos: el l√≠mite superior debe ser mayor al inferior y el paso > 0.");
    return;
  }

  sweepRunning = true;
  log(`üöÄ Iniciando barrido de ${start} Hz a ${end} Hz (paso ${step} Hz, espera ${waitSec}s)`);

  for (let f = start; f <= end; f += step) {
    if (!sweepRunning) break;
    const cmd = `S${Math.round(f)}`;
    socket.emit("send_command", { deviceId: id, command: cmd });
    log(`üì§ Enviado: ${cmd}`);
    await new Promise(res => setTimeout(res, waitSec * 1000));
  }

  sweepRunning = false;
  log("‚úÖ Barrido completado.");
}

function stopSweep() {
  sweepRunning = false;
  log("üõë Barrido detenido por el usuario.");
}
</script>
</body>
</html>
